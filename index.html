<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Linkingdom</title>
    <link rel="stylesheet" href="css/ChessGame.css" />
    <style>
        html,
        body {
            font-family: "Courier New", Courier, monospace;
            width: 100%;
            height: 100%;
            margin: 0px;
        }
    </style>
    <script src="js/ChessGame.js"></script>
</head>

<body>
    <script>
        var turn = 0, record = [], linked = {}, domain = {},
            nextLinkCrd = [],
            chessboard = new Chessboard(13, 13, document.body);
        function linking(chess, sym, needList) {
            if (typeof chess == "string") return linking(chessboard.chesses[chess], sym, needList);
            if (typeof nextLinkCrd.indexOf(chess.crd) > -1) return true;
            var linkedCrd = [],
                dirLinkChess = chess.getChessesByRelCrd("O"),
                rmtLinkChess = chess.getChessesByRelCrd("2O"),
                abnLinkChess = chess.getChessesByRelCrd("IIH,IHH"),
                isOwner = (chess) => chess && chess.symbol == sym && chess.color != "red",
                isSpace = (chess) => chess && ((chess.symbol == "" || chess.symbol == sym) || chess.color == "red");
            for (var i = 0; i < dirLinkChess.length; i++)
                if (isOwner(dirLinkChess[i]))
                    linkedCrd.push(dirLinkChess[i].crd);
            for (var i = 0; i < rmtLinkChess.length; i++) {
                if (!isOwner(rmtLinkChess[i])) continue;
                if (isSpace(dirLinkChess[i]))
                    linkedCrd.push(rmtLinkChess[i].crd);
            }
            for (var i = 0; i < abnLinkChess.length; i++) {
                if (!isOwner(abnLinkChess[i])) continue;
                var relCrd = chess.getRelCrdByChess(abnLinkChess[i]),
                    SVChess = chess.getChessByRelCrd(relCrd.replace(/2./, "")),
                    DVChess = chess.getChessByRelCrd(relCrd.replace(/1./, "")),
                    DSVChess = chess.getChessByRelCrd(relCrd.replace(/1./, "").replace("2", "1")),
                    HVChess = chess.getChessByRelCrd(relCrd.replace("2", "1").replace(/1/g, ""));
                if ((isSpace(HVChess) && (isSpace(SVChess) || isSpace(DSVChess))) || isSpace(DSVChess) && isSpace(DVChess))
                    linkedCrd.push(abnLinkChess[i].crd);
            }
            var crds = "";
            for (var i = 0; i < linkedCrd.length; i++)
                crds += linkedCrd[i] + (linkedCrd.length - 1 == i ? "" : ",");
            if (needList) return linkedCrd;
            return linkedCrd.length > 0;
        }
        function gameResult() {
            linked = { O: [], X: [], all: [] };
            domain = { O: [], X: [], public: [] };
            if (turn < 2) return;
            for (var s = 2; s < turn; s++) {
                chessboard.chesses[record[s]].color = "";
                chessboard.chesses[record[s]].background = "";
            }
            for (var s = 0; s < 2; s++) {
                relateLinker(record[s], s % 2 == 0 ? "O" : "X");
                chessboard.chesses[record[s]].color = "blue";
                chessboard.chesses[record[s]].background = "";
            }
            nextLinkCrd = [];
            var notLinkedFirst = false;
            for (var s = 2; s < turn; s++) {
                var sym = s % 2 == 0 ? "O" : "X",
                    crd = record[s];
                if (linked.all.indexOf(crd) == -1) {
                    var notLinked = true;
                    if (!notLinkedFirst) notLinkedFirst = true;
                    else {
                        var linkedCrd = linking(crd, sym, true);
                        for (var i = 0; i < linkedCrd.length; i++)
                            if (linked[sym].indexOf(linkedCrd[i]) > -1) {
                                notLinked = false;
                                relateLinker(crd, sym);
                                break;
                            }
                    }
                    if (notLinked)
                        chessboard.chesses[crd].color = "red";
                }
            }
            var space = {
                visited: [],
                area: [],
                crd: [],
                count: 0
            };
            for (var s in chessboard.chesses)
                if (chessboard.chesses[s].symbol == "")
                    space.crd.push(s);
            for (var s = 0; s < space.crd.length; s++)
                spaceAssign(space, space.crd[s]);
            for (var s = 0; s < space.area.length; s++)
                domainAssign(space.area[s]);
            for (var s = 0; s < domain.O.length; s++) {
                var chess = chessboard.chesses[domain.O[s]];
                if (chess.symbol == "")
                    chess.background = "indianred";
            }
            for (var s = 0; s < domain.X.length; s++) {
                var chess = chessboard.chesses[domain.X[s]];
                if (chess.symbol == "")
                    chess.background = "lightblue";
            }
            var sym = turn % 2 == 0 ? "O" : "X", winner = "";
            nextLinkConfirm(sym);
            /* for (var s = 0; s < nextLinkCrd.length; s++)
                chessboard.chesses[nextLinkCrd[s]].background = "lightgray"; */
            if (nextLinkCrd.length == 0)
                winner = (turn - 1) % 2 == 0 ? "O" : "X";
            for (var s = 0; s < 2; s++)
                if (domain[s % 2 == 0 ? "O" : "X"].length > domain.public.length / 2)
                    winner = s % 2 == 0 ? "O" : "X";
            if (winner && confirm(winner + " is Win")) {
                turn = 0;
                chessboard.clean();
            }
        }
        function nextLinkConfirm(sym) {
            for (var s in chessboard.chesses)
                if (linking(chessboard.chesses[s], sym))
                    nextLinkCrd.push(s);
        }
        function domainAssign(area) {
            var belong = "unknown";
            for (var s = 0; s < area.length; s++) {
                var crd = area[s],
                    chess = chessboard.chesses[crd],
                    dirArea = chess.getChessesByRelCrd("O");
                for (var i = 0; i < dirArea.length; i++) {
                    if (!dirArea[i] || dirArea[i].color == "red") continue;
                    var sym = dirArea[i].symbol;
                    belong = (sym == "O" && belong == "X") || (sym == "X" && belong == "O") ? "public" : sym != "" ? sym : belong;
                    if (belong == "public") break;
                }
                if (belong == "public") break;
            }
            belong = belong == "unknown" ? "public" : belong;
            domain[belong] = domain[belong].concat(area);
        }
        function relateLinker(crd, sym) {
            var linkedCrd = linking(crd, sym, true);
            if (linked[sym].indexOf(crd) > -1) return;
            linked[sym].push(crd);
            linked.all.push(crd);
            for (var i = 0; i < linkedCrd.length; i++)
                relateLinker(linkedCrd[i], sym);
            return linkedCrd.length > 0;
        }
        function spaceAssign(space, crd) {
            var araIndex = -1;
            chessboard.chesses[crd].background = "";
            if (space.visited.indexOf(crd) > -1) return;
            space.visited.push(crd);
            var dirArea = chessboard.chesses[crd].getChessesByRelCrd("O");
            for (var s = 0; s < space.area.length; s++)
                if (space.area[s].indexOf(crd) > -1) {
                    araIndex = s;
                    break;
                }
            if (araIndex == -1) {
                araIndex = space.area.length;
                space.area.push([crd]);
            }
            for (var s = 0; s < dirArea.length; s++) {
                if (!dirArea[s]) continue;
                var spaceCrd = dirArea[s].crd;
                if ((dirArea[s].symbol == "" || dirArea[s].color == "red") && space.visited.indexOf(spaceCrd) == -1) {
                    space.area[araIndex].push(spaceCrd);
                    spaceAssign(space, spaceCrd);
                }
            }
        }
        for (var s in chessboard.chesses) {
            chessboard.chesses[s].setSpec = function () {
                if (this.symbol != "") return false;
                if (turn < 2) return true;
                var sym = turn % 2 == 0 ? "O" : "X";
                return linking(this, sym);
            }
            chessboard.chesses[s].setProc = function () {
                var sym = turn % 2 == 0 ? "O" : "X";
                this.symbol = sym;
                turn++;
                record.push(this.crd);
                gameResult();
            }
        }
        window.onkeydown = function (evt) {
            if (evt.which != 90) return;
            var crd = record.pop();
            turn--;
            chessboard.chesses[crd].symbol = "";
            gameResult();
        }
    </script>
</body>

</html>